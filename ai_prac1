import heapq

def a_star(graph, heuristic, start, goal):
    open_list = [(0, start)]  # Priority queue (f-score, node)
    g_score = {node: float('inf') for node in graph}  # Initialize g-scores
    g_score[start] = 0
    came_from = {}  # Track path from start to goal

    while open_list:
        f_score, current = heapq.heappop(open_list)  # Get node with lowest f-score
        if current == goal:  # Reconstruct path if goal is reached
            path = []
            while current in came_from: 
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]  # Return reversed path from start to goal
        
        for neighbor, cost in graph[current]:  # Explore neighbors
            temp_g_score = g_score[current] + cost
            if temp_g_score < g_score[neighbor]:  # If better path found
                g_score[neighbor] = temp_g_score
                f_score = temp_g_score + heuristic.get(neighbor, 0)
                heapq.heappush(open_list, (f_score, neighbor))
                came_from[neighbor] = current

    return None  # No path found

# Define graph as adjacency list
graph = {
    'A': [('B', 4), ('C', 3)],
    'B': [('D', 5)],
    'C': [('D', 2), ('E', 6)],
    'D': [('F', 8)],
    'E': [('F', 5)],
    'F': []
}

# Define heuristic values
heuristic = {'A': 10, 'B': 8, 'C': 6, 'D': 4, 'E': 3, 'F': 0}
start, goal = 'A', 'F'
path = a_star(graph, heuristic, start, goal)
print("Shortest Path:", path)
